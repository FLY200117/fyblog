<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>进阶目录 | Fyliue个人博客</title><meta name="description" content="我的个人博客">
    <link rel="modulepreload" href="/fyblog/assets/app.1281bbb5.js"><link rel="modulepreload" href="/fyblog/assets/React2.html.8cd8159a.js"><link rel="modulepreload" href="/fyblog/assets/React2.html.62fff8e5.js"><link rel="prefetch" href="/fyblog/assets/index.html.de110f19.js"><link rel="prefetch" href="/fyblog/assets/DataBase.html.b65f3afc.js"><link rel="prefetch" href="/fyblog/assets/base.html.49bf5ca5.js"><link rel="prefetch" href="/fyblog/assets/best.html.8ce00756.js"><link rel="prefetch" href="/fyblog/assets/algorithm.html.80c150bc.js"><link rel="prefetch" href="/fyblog/assets/blog.html.87519cc1.js"><link rel="prefetch" href="/fyblog/assets/essay.html.70551399.js"><link rel="prefetch" href="/fyblog/assets/前后端分离.html.44933d91.js"><link rel="prefetch" href="/fyblog/assets/Deno.html.1e40011e.js"><link rel="prefetch" href="/fyblog/assets/Node-Nest.html.5366b354.js"><link rel="prefetch" href="/fyblog/assets/Node-express.html.c5b1f8ee.js"><link rel="prefetch" href="/fyblog/assets/ComputerBasics.html.725ba5c1.js"><link rel="prefetch" href="/fyblog/assets/DataStructure.html.a8d297a6.js"><link rel="prefetch" href="/fyblog/assets/DesignMode.html.1ea7ea91.js"><link rel="prefetch" href="/fyblog/assets/Browser.html.f9f1e54e.js"><link rel="prefetch" href="/fyblog/assets/CSS.html.3f8330ca.js"><link rel="prefetch" href="/fyblog/assets/HTML.html.b0fef6ca.js"><link rel="prefetch" href="/fyblog/assets/JavaScript.html.2e868a5c.js"><link rel="prefetch" href="/fyblog/assets/Network.html.aa6aaf16.js"><link rel="prefetch" href="/fyblog/assets/TypeScript.html.23be7c0a.js"><link rel="prefetch" href="/fyblog/assets/TypeScript2.html.7815d8a3.js"><link rel="prefetch" href="/fyblog/assets/React.html.8af3740a.js"><link rel="prefetch" href="/fyblog/assets/Redux.html.815138fd.js"><link rel="prefetch" href="/fyblog/assets/Vue2.html.4d6414cf.js"><link rel="prefetch" href="/fyblog/assets/Vue3.html.f8cc0e2a.js"><link rel="prefetch" href="/fyblog/assets/Vuex.html.77e2cabb.js"><link rel="prefetch" href="/fyblog/assets/mobx.html.2d26aef3.js"><link rel="prefetch" href="/fyblog/assets/pinia.html.9a0e66c0.js"><link rel="prefetch" href="/fyblog/assets/Cli.html.a035dbf3.js"><link rel="prefetch" href="/fyblog/assets/Micro-Frontends.html.683fc14f.js"><link rel="prefetch" href="/fyblog/assets/PackagingTools.html.93e1c6d8.js"><link rel="prefetch" href="/fyblog/assets/MobileDevices.html.048f40f4.js"><link rel="prefetch" href="/fyblog/assets/WeChat.html.164315ed.js"><link rel="prefetch" href="/fyblog/assets/desktop.html.bf07d612.js"><link rel="prefetch" href="/fyblog/assets/desktop2.html.ed5c4d9c.js"><link rel="prefetch" href="/fyblog/assets/404.html.c3e557d0.js"><link rel="prefetch" href="/fyblog/assets/index.html.ff7da184.js"><link rel="prefetch" href="/fyblog/assets/DataBase.html.00c8bf7a.js"><link rel="prefetch" href="/fyblog/assets/base.html.086b440a.js"><link rel="prefetch" href="/fyblog/assets/best.html.9e3bc9d0.js"><link rel="prefetch" href="/fyblog/assets/algorithm.html.a551fe48.js"><link rel="prefetch" href="/fyblog/assets/blog.html.64ea2283.js"><link rel="prefetch" href="/fyblog/assets/essay.html.8de6f250.js"><link rel="prefetch" href="/fyblog/assets/前后端分离.html.6f1d2224.js"><link rel="prefetch" href="/fyblog/assets/Deno.html.b334a5b6.js"><link rel="prefetch" href="/fyblog/assets/Node-Nest.html.75b2b216.js"><link rel="prefetch" href="/fyblog/assets/Node-express.html.2ec395b4.js"><link rel="prefetch" href="/fyblog/assets/ComputerBasics.html.b95f06aa.js"><link rel="prefetch" href="/fyblog/assets/DataStructure.html.07f99842.js"><link rel="prefetch" href="/fyblog/assets/DesignMode.html.2e69d004.js"><link rel="prefetch" href="/fyblog/assets/Browser.html.3b5e91fc.js"><link rel="prefetch" href="/fyblog/assets/CSS.html.55c730c5.js"><link rel="prefetch" href="/fyblog/assets/HTML.html.4d614d1e.js"><link rel="prefetch" href="/fyblog/assets/JavaScript.html.303602ac.js"><link rel="prefetch" href="/fyblog/assets/Network.html.af8bc877.js"><link rel="prefetch" href="/fyblog/assets/TypeScript.html.5d30c748.js"><link rel="prefetch" href="/fyblog/assets/TypeScript2.html.231e7251.js"><link rel="prefetch" href="/fyblog/assets/React.html.1aff298a.js"><link rel="prefetch" href="/fyblog/assets/Redux.html.d8c36d62.js"><link rel="prefetch" href="/fyblog/assets/Vue2.html.a6307ab5.js"><link rel="prefetch" href="/fyblog/assets/Vue3.html.ec8cd299.js"><link rel="prefetch" href="/fyblog/assets/Vuex.html.e866b1a1.js"><link rel="prefetch" href="/fyblog/assets/mobx.html.5ff98fa0.js"><link rel="prefetch" href="/fyblog/assets/pinia.html.bc37023d.js"><link rel="prefetch" href="/fyblog/assets/Cli.html.cab43da5.js"><link rel="prefetch" href="/fyblog/assets/Micro-Frontends.html.2ed6f41d.js"><link rel="prefetch" href="/fyblog/assets/PackagingTools.html.89b9c4a0.js"><link rel="prefetch" href="/fyblog/assets/MobileDevices.html.82231eba.js"><link rel="prefetch" href="/fyblog/assets/WeChat.html.5b23f1ad.js"><link rel="prefetch" href="/fyblog/assets/desktop.html.9b38ff45.js"><link rel="prefetch" href="/fyblog/assets/desktop2.html.7ebe9b5e.js"><link rel="prefetch" href="/fyblog/assets/404.html.bcde5bfa.js"><link rel="prefetch" href="/fyblog/assets/giscus.ded2036a.js">
    <link rel="stylesheet" href="/fyblog/assets/style.29ecf867.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/fyblog/" class=""><!----><span class="site-name">Fyliue个人博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/fyblog/" class="" aria-label="主页"><!--[--><!--]--> 主页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端"><span class="title">前端</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/html" class="" aria-label="html"><!--[--><!--]--> html <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/css" class="" aria-label="css"><!--[--><!--]--> css <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/JavaScript" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/TypeScript" class="" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/network&amp;browser" class="" aria-label="网络基础与浏览器"><!--[--><!--]--> 网络基础与浏览器 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/frame/Vue2" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/frame/React" class="router-link-active" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>不仅仅是Browser</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/platform/MobileDevices" class="" aria-label="移动端"><!--[--><!--]--> 移动端 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/platform/desktop" class="" aria-label="桌面端"><!--[--><!--]--> 桌面端 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/platform/WeChat" class="" aria-label="小程序"><!--[--><!--]--> 小程序 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>额外知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/more/PackagingTools" class="" aria-label="webpack与Vite"><!--[--><!--]--> webpack与Vite <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/more/Cli" class="" aria-label="脚手架"><!--[--><!--]--> 脚手架 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/more/Micro-Frontends" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="后端"><span class="title">后端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="后端"><span class="title">后端</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/fyblog/pages/Server/base" class="" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Server/best" class="" aria-label="进阶"><!--[--><!--]--> 进阶 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Server/DataBase" class="" aria-label="数据库"><!--[--><!--]--> 数据库 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Server/frame/Node-express" class="" aria-label="Node-express"><!--[--><!--]--> Node-express <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Server/frame/Node-Nest" class="" aria-label="Node-Nest"><!--[--><!--]--> Node-Nest <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Server/frame/Deno" class="" aria-label="Deno"><!--[--><!--]--> Deno <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="技术"><span class="title">技术</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="技术"><span class="title">技术</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Skill/base/DataStructure" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Skill/base/DesignMode" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Skill/base/ComputerBasics" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Skill/algorithm" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Skill/essay" class="" aria-label="随笔"><!--[--><!--]--> 随笔 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/FLY200117" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/fyblog/" class="" aria-label="主页"><!--[--><!--]--> 主页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端"><span class="title">前端</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/html" class="" aria-label="html"><!--[--><!--]--> html <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/css" class="" aria-label="css"><!--[--><!--]--> css <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/JavaScript" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/TypeScript" class="" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/base/network&amp;browser" class="" aria-label="网络基础与浏览器"><!--[--><!--]--> 网络基础与浏览器 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/frame/Vue2" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/frame/React" class="router-link-active" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>不仅仅是Browser</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/platform/MobileDevices" class="" aria-label="移动端"><!--[--><!--]--> 移动端 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/platform/desktop" class="" aria-label="桌面端"><!--[--><!--]--> 桌面端 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/platform/WeChat" class="" aria-label="小程序"><!--[--><!--]--> 小程序 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>额外知识</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/more/PackagingTools" class="" aria-label="webpack与Vite"><!--[--><!--]--> webpack与Vite <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/more/Cli" class="" aria-label="脚手架"><!--[--><!--]--> 脚手架 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Web/more/Micro-Frontends" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="后端"><span class="title">后端</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="后端"><span class="title">后端</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/fyblog/pages/Server/base" class="" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Server/best" class="" aria-label="进阶"><!--[--><!--]--> 进阶 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Server/DataBase" class="" aria-label="数据库"><!--[--><!--]--> 数据库 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>框架</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Server/frame/Node-express" class="" aria-label="Node-express"><!--[--><!--]--> Node-express <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Server/frame/Node-Nest" class="" aria-label="Node-Nest"><!--[--><!--]--> Node-Nest <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Server/frame/Deno" class="" aria-label="Deno"><!--[--><!--]--> Deno <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="技术"><span class="title">技术</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="技术"><span class="title">技术</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>基础</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Skill/base/DataStructure" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Skill/base/DesignMode" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/fyblog/pages/Skill/base/ComputerBasics" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Skill/algorithm" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/fyblog/pages/Skill/essay" class="" aria-label="随笔"><!--[--><!--]--> 随笔 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/FLY200117" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Vue <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/fyblog/pages/Web/frame/Vue2.html" class="sidebar-item" aria-label="Vue2"><!--[--><!--]--> Vue2 <!--[--><!--]--></a><!----></li><li><a href="/fyblog/pages/Web/frame/Vue3.html" class="sidebar-item" aria-label="Vue3"><!--[--><!--]--> Vue3 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">React <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/fyblog/pages/Web/frame/React.html" class="sidebar-item" aria-label="基础目录"><!--[--><!--]--> 基础目录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="进阶目录"><!--[--><!--]--> 进阶目录 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#reconciliation-协调" class="router-link-active router-link-exact-active sidebar-item" aria-label="Reconciliation（协调）"><!--[--><!--]--> Reconciliation（协调） <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#设计动机" class="router-link-active router-link-exact-active sidebar-item" aria-label="设计动机"><!--[--><!--]--> 设计动机 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#diffing算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Diffing算法"><!--[--><!--]--> Diffing算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fiber"><!--[--><!--]--> Fiber <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber的重要型" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fiber的重要型"><!--[--><!--]--> Fiber的重要型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#什么是fiber" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是Fiber"><!--[--><!--]--> 什么是Fiber <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#requestanimationframe-绘制动画api" class="router-link-active router-link-exact-active sidebar-item" aria-label="requestAnimationFrame（绘制动画API）"><!--[--><!--]--> requestAnimationFrame（绘制动画API） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#requestidlecallback-后台执行api" class="router-link-active router-link-exact-active sidebar-item" aria-label="requestIdleCallback（后台执行API）"><!--[--><!--]--> requestIdleCallback（后台执行API） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber链表结构设计" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fiber链表结构设计"><!--[--><!--]--> Fiber链表结构设计 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber节点设计" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fiber节点设计"><!--[--><!--]--> Fiber节点设计 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber执行原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fiber执行原理"><!--[--><!--]--> Fiber执行原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">状态管理 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/fyblog/pages/Web/frame/Vuex.html" class="sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!----></li><li><a href="/fyblog/pages/Web/frame/Redux.html" class="sidebar-item" aria-label="Redux基础"><!--[--><!--]--> Redux基础 <!--[--><!--]--></a><!----></li><li><a href="/fyblog/pages/Web/frame/pinia.html" class="sidebar-item" aria-label="pinia"><!--[--><!--]--> pinia <!--[--><!--]--></a><!----></li><li><a href="/fyblog/pages/Web/frame/mobx.html" class="sidebar-item" aria-label="mobx"><!--[--><!--]--> mobx <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="进阶目录" tabindex="-1"><a class="header-anchor" href="#进阶目录" aria-hidden="true">#</a> 进阶目录</h1><nav class="table-of-contents"><ul><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#reconciliation-协调" class="router-link-active router-link-exact-active">Reconciliation（协调）</a><ul><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#设计动机" class="router-link-active router-link-exact-active">设计动机</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#diffing算法" class="router-link-active router-link-exact-active">Diffing算法</a></li></ul></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber" class="router-link-active router-link-exact-active">Fiber</a><ul><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber的重要型" class="router-link-active router-link-exact-active">Fiber的重要型</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#什么是fiber" class="router-link-active router-link-exact-active">什么是Fiber</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#requestanimationframe-绘制动画api" class="router-link-active router-link-exact-active">requestAnimationFrame（绘制动画API）</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#requestidlecallback-后台执行api" class="router-link-active router-link-exact-active">requestIdleCallback（后台执行API）</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber链表结构设计" class="router-link-active router-link-exact-active">Fiber链表结构设计</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber节点设计" class="router-link-active router-link-exact-active">Fiber节点设计</a></li><li><a aria-current="page" href="/fyblog/pages/Web/frame/React2.html#fiber执行原理" class="router-link-active router-link-exact-active">Fiber执行原理</a></li></ul></li></ul></nav><p>在了解Fiber之前，需要知道的是现在流行的VDOM（Virtual DOM），以下是官网给出的对VDOM的解释：Virtual DOM 是一种编程概念。在这个概念里， UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫做<a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer">协调<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p>Vue和其他主流框架底层都是运用了VDOM，原因是因为浏览器底层对DOM的直接操作过于浪费，所以将真实DOM映射成下面这种形式：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token literal-property property">ElementType</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
	<span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">&#39;className&#39;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">att</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token literal-property property">style</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这样的&quot;虚拟&quot;DOM去<code>统一</code>的操作DOM，在这基础上，还增加了<code>diff</code>算法，这里就不过多讲述<code>diff</code>算法，由VDOM这一技术陆陆续续又衍生了许多其他技术，这里就不过多讲解。</p><p>注意：<strong>Shadow DOM和VDOM并不一样</strong>，前者是一种浏览器技术，主要是在web组件中封装变量和CSS，而VDOM则更像是JS库基于浏览器API实现的概念，<strong>与其将 “Virtual DOM” 视为一种技术，不如说它是一种模式</strong></p><h2 id="reconciliation-协调" tabindex="-1"><a class="header-anchor" href="#reconciliation-协调" aria-hidden="true">#</a> Reconciliation（协调）</h2><h3 id="设计动机" tabindex="-1"><a class="header-anchor" href="#设计动机" aria-hidden="true">#</a> 设计动机</h3><p>在某一时间节点调用 React 的 <code>render()</code> 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 <code>render()</code> 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步</p><p>此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用<a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener noreferrer">最优的算法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量</p><p>如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：</p><ol><li>两个不同类型的元素会产生出不同的树；</li><li>开发者可以使用 <code>key</code> 属性标识哪些子元素在不同的渲染中可能是不变的。</li></ol><p>在实践中，我们发现以上假设在几乎所有实用的场景下都成立。</p><h3 id="diffing算法" tabindex="-1"><a class="header-anchor" href="#diffing算法" aria-hidden="true">#</a> Diffing算法</h3><p>当对比两棵树时，React首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态</p><h4 id="对比不同类型的元素" tabindex="-1"><a class="header-anchor" href="#对比不同类型的元素" aria-hidden="true">#</a> 对比不同类型的元素</h4><p>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。举个例子，当一个元素从 <code>&lt;a&gt;</code> 变成 <code>&lt;img&gt;</code>，从 <code>&lt;Article&gt;</code> 变成 <code>&lt;Comment&gt;</code>，或从 <code>&lt;Button&gt;</code> 变成 <code>&lt;div&gt;</code> 都会触发一个完整的重建流程</p><p>当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 <code>componentWillUnmount()</code> 方法。当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 <code>UNSAFE_componentWillMount()</code> 方法，紧接着 <code>componentDidMount()</code> 方法。所有与之前的树相关联的 state 也会被销毁</p><p>在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Counter</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Counter</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 会销毁 <code>Counter</code> 组件并且重新装载一个新的组件。</p><h4 id="对比同一类型的元素" tabindex="-1"><a class="header-anchor" href="#对比同一类型的元素" aria-hidden="true">#</a> 对比同一类型的元素</h4><p>当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>before<span class="token punctuation">&quot;</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stuff<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>after<span class="token punctuation">&quot;</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stuff<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>className</code> 属性。</p><p>当更新 <code>style</code> 属性时，React 仅更新有所更变的属性。比如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token value css language-css"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span></span></span></span> <span class="token attr-name">&#39;red&#39;,</span> <span class="token attr-name"><span class="token namespace">fontWeight:</span></span> <span class="token attr-name">&#39;bold&#39;}}</span> <span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token value css language-css"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span></span></span></span> <span class="token attr-name">&#39;green&#39;,</span> <span class="token attr-name"><span class="token namespace">fontWeight:</span></span> <span class="token attr-name">&#39;bold&#39;}}</span> <span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>color</code> 样式，无需修改 <code>fontWeight</code>。</p><p>在处理完当前节点之后，React 继续对子节点进行递归。</p><h4 id="对比同类型的组件元素" tabindex="-1"><a class="header-anchor" href="#对比同类型的组件元素" aria-hidden="true">#</a> 对比同类型的组件元素</h4><p>当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 <code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code> 方法。</p><p>下一步，调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归。</p><h4 id="对子节点进行递归" tabindex="-1"><a class="header-anchor" href="#对子节点进行递归" aria-hidden="true">#</a> 对子节点进行递归</h4><p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation</p><p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>first<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>first<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>second<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>third<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt;</code> 对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的 <code>&lt;li&gt;third&lt;/li&gt;</code> 树</p><p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Connecticut<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题</p><h4 id="keys" tabindex="-1"><a class="header-anchor" href="#keys" aria-hidden="true">#</a> Keys</h4><p>为了解决上述问题，React 引入了 <code>key</code> 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 <code>key</code> 之后，使得树的转换效率得以提高：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2015<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2016<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2014<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Connecticut<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2015<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Duke<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2016<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Villanova<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在 React 知道只有带着 <code>&#39;2014&#39;</code> key 的元素是新元素，带着 <code>&#39;2015&#39;</code> 以及 <code>&#39;2016&#39;</code> key 的元素仅仅移动了</p><p>可以新增一个 ID 字段到模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在<strong>列表</strong>中需要保持唯一</p><p>最后，你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢</p><p>当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动</p><h2 id="fiber" tabindex="-1"><a class="header-anchor" href="#fiber" aria-hidden="true">#</a> Fiber</h2><p>Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染，提高其在动画， 布局和手势等领域的适用性。能够将渲染工作分割成块，并将其分散到多个帧上。Fiber 是对 React 核心<strong>算法</strong>的重构，facebook 团队使用两年多的时间去重构 React 的核心算法，在React16 以上的版本中引入了 Fiber 架构</p><h3 id="fiber的重要型" tabindex="-1"><a class="header-anchor" href="#fiber的重要型" aria-hidden="true">#</a> Fiber的重要型</h3><p>在浏览器中，页面是一帧帧绘制出来的，渲染的帧率与设备的刷新率保持一致，一般情况下是1s 60次，当每秒内绘制的帧数（FPS）超过60时，页面渲染是流畅的，当小于60的时候则会出现一定的卡顿现象</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f288e9135ed414d871ad2fd2715d85d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><ol><li>首先需要处理输入时间，能让用户得到最早的反馈</li><li>处理定时器，需要检查定时器是否到时间，并执行对应的回调</li><li>接下来处理Begin Frame（开始帧），即每一帧的时间，包括 window.resize、scroll、media query change 等</li><li>接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调</li><li>紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示</li><li>接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充</li><li>到这时以上的六个阶段都已经完成了，接下来处于空闲阶段（Idle Peroid），可以在这时执行 requestIdleCallback 里注册的任务（后面会详细讲到这个 requestIdleCallback ，它是 React Fiber 实现的基础）</li></ol><p>js引擎和页面渲染引擎是在同一个渲染线程之内，两者是互斥关系。如果在某个阶段执行任务特别长，例如在定时器阶段或<code>Begin Frame</code>阶段执行时间非常长，时间已经明显超过了16ms，那么就会阻塞页面的渲染，从而出现卡顿现象。</p><p>在 react16 引入 Fiber 架构之前，react 会采用先序递归对比虚拟DOM树，找出需要变动的节点，然后同步更新它们，这个过程 react 称为<code>reconcilation</code>（协调）。在<code>reconcilation</code>期间，react 会一直占用浏览器资源，会导致用户触发的事件得不到响应。实现的原理如下所示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994d70ab12f14d079e6c0b98d0e1b326~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>这种遍历是递归调用，执行栈会越来越深，而且不能中断，中断后就不能恢复了。递归如果非常深，就会十分卡顿。如果递归花了100ms，则这100ms浏览器是无法响应的，代码执行时间越长卡顿越明显。传统的方法存在不能中断和执行栈太深的问题。</p><p>因此，为了解决以上的痛点问题，React希望能够彻底解决主线程长时间占用问题，于是引入了 Fiber 来改变这种不可控的现状，把渲染/更新过程拆分为一个个小块的任务，通过合理的调度机制来调控时间，指定任务执行的时机，从而降低页面卡顿的概率，提升页面交互体验。通过Fiber架构，让<code>reconcilation</code>过程变得可被中断。适时地让出CPU执行权，可以让浏览器及时地响应用户的交互。</p><p>React16中使用了 Fiber，但是 Vue 是没有 Fiber 的，为什么呢？原因是二者的优化思路不一样：</p><ul><li>Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分</li><li>React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务</li></ul><h3 id="什么是fiber" tabindex="-1"><a class="header-anchor" href="#什么是fiber" aria-hidden="true">#</a> 什么是Fiber</h3><p>Fiber 可以理解为是一个执行单元，也可以理解为是一种数据结构。</p><h4 id="执行单位" tabindex="-1"><a class="header-anchor" href="#执行单位" aria-hidden="true">#</a> 执行单位</h4><p>Fiber 可以理解为一个执行单元，每次执行完一个执行单元，react 就会检查现在还剩多少时间，如果没有时间则将控制权让出去。React Fiber 与浏览器的核心交互流程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78a602cbc87342628ace49abb5d20c39~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>首先 React 向浏览器请求调度，浏览器在一帧中如果还有空闲时间，会去判断是否存在待执行任务，不存在就直接将控制权交给浏览器，如果存在就会执行对应的任务，执行完成后会判断是否还有时间，有时间且有待执行任务则会继续执行下一个任务，否则就会将控制权交给浏览器。这里会有点绕，可以结合上述的图进行理解</p><p>Fiber 可以被理解为划分一个个更小的执行单元，它是把一个大任务拆分为了很多个小块任务，一个小块任务的执行必须是一次完成的，不能出现暂停，但是一个小块任务执行完后可以移交控制权给浏览器去响应用户，从而不用像之前一样要等那个大任务一直执行完成再去响应用户</p><h4 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h4><p>Fiber 还可以理解为是一种数据结构，React Fiber 就是采用链表实现的。每个 Virtual DOM 都可以表示为一个 fiber，如下图所示，每个节点都是一个 fiber。一个 fiber包括了 child（第一个子节点）、sibling（兄弟节点）、return（父节点）等属性，React Fiber 机制的实现，就是依赖于以下的数据结构</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74fe5e7d1dc449568448b462abcbff6e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><h3 id="requestanimationframe-绘制动画api" tabindex="-1"><a class="header-anchor" href="#requestanimationframe-绘制动画api" aria-hidden="true">#</a> requestAnimationFrame（绘制动画API）</h3><p>在 Fiber 中使用到了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame" target="_blank" rel="noopener noreferrer">requestAnimationFrame<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，它是浏览器提供的绘制动画的 api 。它要求浏览器在下次重绘之前（即下一帧）调用指定的回调函数更新动画</p><h3 id="requestidlecallback-后台执行api" tabindex="-1"><a class="header-anchor" href="#requestidlecallback-后台执行api" aria-hidden="true">#</a> requestIdleCallback（后台执行API）</h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 也是 react Fiber 实现的基础 api 。我们希望能够快速响应用户，让用户觉得够快，不能阻塞用户的交互，<code>requestIdleCallback</code>能使开发者在主事件循环上执行后台和低优先级的工作，而不影响延迟关键事件，如动画和输入响应。正常帧任务完成后没超过16ms，说明有多余的空闲时间，此时就会执行<code>requestIdleCallback</code>里注册的任务</p><p>具体的执行流程如下，开发者采用<code>requestIdleCallback</code>方法注册对应的任务，告诉浏览器我的这个任务优先级不高，如果每一帧内存在空闲时间，就可以执行注册的这个任务。另外，开发者是可以传入<code>timeout</code>参数去定义超时时间的，如果到了超时时间了，浏览器必须立即执行，使用方法如下：<code>window.requestIdleCallback(callback, { timeout: 1000 })</code>。浏览器执行完这个方法后，如果没有剩余时间了，或者已经没有下一个可执行的任务了，React应该归还控制权，并同样使用<code>requestIdleCallback</code>去申请下一个时间片。具体的流程如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/043bc29786cd4053a056f95d3256cb2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p><code>window.requestIdleCallback(callback)</code>的<code>callback</code>中会接收到默认参数 deadline ，其中包含了以下两个属性：</p><ul><li>timeRamining 返回当前帧还剩多少时间供用户使用</li><li>didTimeout 返回 callback 任务是否超时</li></ul><p>这里需要注意的是，浏览器一帧的严格时间并不是16ms，是可以动态控制的，如果子任务时间超过了一帧的剩余时间，则会一直卡在这里执行，直到代码执行完毕。如果代码存在死循环，则浏览器会卡死，如果此帧的剩余时间大于0（有空余时间）或者已经超时，且当时存在任务，则直接执行该任务。如果没有剩余时间，则应该放弃执行任务控制权，把执行权交还给浏览器。如果多个任务执行总时间小于空闲时间的话，是可以在一帧内执行多个任务的。</p><h3 id="fiber链表结构设计" tabindex="-1"><a class="header-anchor" href="#fiber链表结构设计" aria-hidden="true">#</a> Fiber链表结构设计</h3><p>Fiber结构是使用链表实现的，<code>Fiber tree</code>实际上是个单链表树结构，详见<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fmaster%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiber.new.js" target="_blank" rel="noopener noreferrer">ReactFiber.js源码<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，在这里我们看看Fiber的链表结构是怎样的，了解了这个链表结构后，能更快地理解后续 Fiber 的遍历过程。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b440a981e4c040b2ab3523f065bffea7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>以上每一个单元包含了<code>payload</code>（数据）和<code>nextUpdate</code>（指向下一个单元的指针），定义结构如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Update</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">payload<span class="token punctuation">,</span> nextUpdate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>payload <span class="token operator">=</span> payload <span class="token comment">// payload 数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nextUpdate <span class="token operator">=</span> nextUpdate <span class="token comment">// 指向下一个节点的指针</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来定义一个队列，把每个单元串联起来，其中定义了两个指针：头指针<code>firstUpdate</code>和尾指针<code>lastUpdate</code>，作用是指向第一个单元和最后一个单元，并加入了<code>baseState</code>属性存储React中的state状态。如下所示：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">UpdateQueue</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>baseState <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// state</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>firstUpdate <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 第一个更新</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lastUpdate <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 最后一个更新</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来定义两个方法：插入节点单元（enqueueUpdate）、更新队列（forceUpdate）。插入节点单元时需要考虑是否已经存在节点，如果不存在直接将<code>firstUpdate</code>、<code>lastUpdate</code>指向此节点即可。更新队列是遍历这个链表，根据<code>payload</code>中的内容去更新<code>state</code>的值。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">UpdateQueue</span> <span class="token punctuation">{</span>
  <span class="token comment">//.....</span>
  
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token parameter">update</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前链表是空链表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>firstUpdate <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastUpdate <span class="token operator">=</span> update
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当前链表不为空</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>lastUpdate<span class="token punctuation">.</span>nextUpdate <span class="token operator">=</span> update
      <span class="token keyword">this</span><span class="token punctuation">.</span>lastUpdate <span class="token operator">=</span> update
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 获取state，然后遍历这个链表，进行更新</span>
  <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentState <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>baseState <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">let</span> currentUpdate <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstUpdate
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是函数还是对象，是函数则需要执行，是对象则直接返回</span>
      <span class="token keyword">let</span> nextState <span class="token operator">=</span> <span class="token keyword">typeof</span> currentUpdate<span class="token punctuation">.</span>payload <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">?</span> currentUpdate<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span>currentState<span class="token punctuation">)</span> <span class="token operator">:</span> currentUpdate<span class="token punctuation">.</span>payload
      currentState <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>currentState<span class="token punctuation">,</span> <span class="token operator">...</span>nextState <span class="token punctuation">}</span>
      currentUpdate <span class="token operator">=</span> currentUpdate<span class="token punctuation">.</span>nextUpdate
    <span class="token punctuation">}</span>
    <span class="token comment">// 更新完成后清空链表</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>firstUpdate <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastUpdate <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>baseState <span class="token operator">=</span> currentState
    <span class="token keyword">return</span> currentState
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后实例化一个队列，向其中加入很多节点，再更新这个队列</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UpdateQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Update</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;www&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Update</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Update</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">age</span><span class="token operator">:</span> state<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Update</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">age</span><span class="token operator">:</span> state<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="fiber节点设计" tabindex="-1"><a class="header-anchor" href="#fiber节点设计" aria-hidden="true">#</a> Fiber节点设计</h3><p>Fiber的拆分单位是fiber（<code>fiber tree</code>上的一个节点），实际上就是按虚拟DOM节点拆，我们需要根据虚拟dom去生成 Fiber 树。下文中我们把每一个节点叫做 fiber 。fiber 节点结构如下</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
    
    <span class="token literal-property property">type</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token comment">// 对于类组件，它指向构造函数；对于DOM元素，它指定HTML tag</span>
    <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span> <span class="token comment">// 唯一标识符</span>
    <span class="token literal-property property">stateNode</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token comment">// 保存对组件的类实例，DOM节点或与fiber节点关联的其他React元素类型的引用</span>
    <span class="token literal-property property">child</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 大儿子</span>
    <span class="token literal-property property">sibling</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 下一个兄弟</span>
    <span class="token keyword">return</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 父节点</span>
    <span class="token literal-property property">tag</span><span class="token operator">:</span> WorkTag<span class="token punctuation">,</span> <span class="token comment">// 定义fiber操作的类型, 详见https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactWorkTags.js</span>
    <span class="token literal-property property">nextEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 指向下一个节点的指针</span>
    <span class="token literal-property property">updateQueue</span><span class="token operator">:</span> mixed<span class="token punctuation">,</span> <span class="token comment">// 用于状态更新，回调函数，DOM更新的队列</span>
    <span class="token literal-property property">memoizedState</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token comment">// 用于创建输出的fiber状态</span>
    <span class="token literal-property property">pendingProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token comment">// 已从React元素中的新数据更新，并且需要应用于子组件或DOM元素的props</span>
    <span class="token literal-property property">memoizedProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token comment">// 在前一次渲染期间用于创建输出的props</span>
    <span class="token comment">// ……     </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>fiber节点包括了以下属性：</p><ol><li>type &amp; key</li></ol><ul><li>fiber的type和key与React元素的作用相同。fiber的type描述了它对应的组件，对于复合组件，type是函数或者类组件本身。对于原生标签，type是一个字符串。随着type的不同，在reconciliation期间使用key来确定fiber是否可以重新使用</li></ul><ol start="2"><li>stateNode</li></ol><ul><li>stateNode 保存对组件的类实例，DOM节点或与 fiber 节点关联的其他 React 元素类型的引用。一般来说，可以认为这个属性用于保存与 fiber 相关的本地状态</li></ul><ol start="3"><li>child &amp; sibling &amp; return</li></ol><ul><li><h6 id="child-属性指向此节点的第一个子节点-大儿子-。" tabindex="-1"><a class="header-anchor" href="#child-属性指向此节点的第一个子节点-大儿子-。" aria-hidden="true">#</a> child 属性指向此节点的第一个子节点（大儿子）。</h6></li><li><p>sibling 属性指向此节点的下一个兄弟节点（大儿子指向二儿子、二儿子指向三儿子）</p></li><li><p>return 属性指向此节点的父节点，即当前节点处理完毕后，应该向谁提交自己的成果。如果 fiber 具有多个子 fiber，则每个子 fiber 的 return fiber 是 parent</p></li></ul><p>所有 fiber 节点都通过以下属性：child，sibling 和 return来构成一个 fiber node 的 linked list(后面称之为链表)。如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5192251a0a47481aacb6e018b1741655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>其他的属性还有<code>memoizedState</code>（创建输出的 fiber 的状态）、<code>pendingProps</code>（将要改变的 props ）、<code>memoizedProps</code>（上次渲染创建输出的 props ）、<code>pendingWorkPriority</code>（定义 fiber 工作优先级）等等</p><h3 id="fiber执行原理" tabindex="-1"><a class="header-anchor" href="#fiber执行原理" aria-hidden="true">#</a> Fiber执行原理</h3><p>从根节点开始渲染和调度的过程可以分为两个阶段：render阶段，commit阶段</p><ul><li>render阶段：该阶段是可中断的，会找出所有节点的变更</li><li>commit阶段：该阶段是不可中断的，会执行所有的变更</li></ul><h4 id="render阶段" tabindex="-1"><a class="header-anchor" href="#render阶段" aria-hidden="true">#</a> render阶段</h4><p>此阶段会找出所有节点的变更，如节点新增、删除、属性变更等，这些变更 react 统称为副作用（effect），此阶段会构建一棵<code>Fiber tree</code>，以虚拟dom节点为维度对任务进行拆分，即一个虚拟dom节点对应一个任务，最后产出的结果是<code>effect list</code>，从中可以知道哪些节点更新、哪些节点增加、哪些节点删除了</p><h5 id="遍历流程" tabindex="-1"><a class="header-anchor" href="#遍历流程" aria-hidden="true">#</a> 遍历流程</h5><p><code>React Fiber</code>首先是将虚拟DOM树转化为<code>Fiber tree</code>，因此每个节点都有<code>child</code>、<code>sibling</code>、<code>return</code>属性，遍历<code>Fiber tree</code>时采用的是后序遍历方法：</p><ol><li>如果有大儿子，先遍历大儿子；如果没有大儿子，则表示遍历完成</li><li>大儿子： a. 如果有弟弟，则返回弟弟，跳到2 b. 如果没有弟弟，则返回父节点，并标志完成父节点遍历，跳到2 d. 如果没有父节点则标志遍历结束</li><li>遍历完所有节点后，自己才完成</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e617a3507074e498318332b579cd634~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><h5 id="收集effect-list" tabindex="-1"><a class="header-anchor" href="#收集effect-list" aria-hidden="true">#</a> 收集effect list</h5><p>知道了遍历方法之后，接下来需要做的工作就是在遍历过程中，收集所有节点的变更产出<code>effect list</code>，注意其中只包含了需要变更的节点。通过每个节点更新结束时向上归并<code>effect list</code>来收集任务结果，最后根节点的<code>effect list</code>里就记录了包括了所有需要变更的结果。</p><p>收集<code>effect list</code>的具体步骤为：</p><ol><li><p>如果当前节点需要更新，则打<code>tag</code>更新当前节点状态（props, state, context等）</p></li><li><p>为每个子节点创建fiber。如果没有产生<code>child fiber</code>，则结束该节点，把<code>effect list</code>归并到<code>return</code>，把此节点的<code>sibling</code>节点作为下一个遍历节点；否则把<code>child</code>节点作为下一个遍历节点</p></li><li><p>如果有剩余时间，则开始下一个节点，否则等下一次主线程空闲再开始下一个节点</p></li><li><p>如果没有下一个节点了，进入<code>pendingCommit</code>状态，此时<code>effect list</code>收集完毕，结束。</p></li></ol><p>收集<code>effect list</code>的遍历顺序如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36484ed7dca5465695c99f7fe329ed6d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>遍历子虚拟DOM元素数组，为每个虚拟DOM元素创建子fiber：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">reconcileChildren</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">currentFiber<span class="token punctuation">,</span> newChildren</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newChildIndex <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">let</span> prevSibling <span class="token comment">// 上一个子fiber</span>

  <span class="token comment">// 遍历子虚拟DOM元素数组，为每个虚拟DOM元素创建子fiber</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>newChildIndex <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> newChild <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>newChildIndex<span class="token punctuation">]</span>
    <span class="token keyword">let</span> tag
    <span class="token comment">// 打tag，定义 fiber类型</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newChild<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">ELEMENT_TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这是文本节点</span>
      tag <span class="token operator">=</span> <span class="token constant">TAG_TEXT</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newChild<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果type是字符串，则是原生DOM节点</span>
      tag <span class="token operator">=</span> <span class="token constant">TAG_HOST</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> newFiber <span class="token operator">=</span> <span class="token punctuation">{</span>
      tag<span class="token punctuation">,</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> newChild<span class="token punctuation">.</span>type<span class="token punctuation">,</span>
      <span class="token literal-property property">props</span><span class="token operator">:</span> newChild<span class="token punctuation">.</span>props<span class="token punctuation">,</span>
      <span class="token literal-property property">stateNode</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 还未创建DOM元素</span>
      <span class="token keyword">return</span><span class="token operator">:</span> currentFiber<span class="token punctuation">,</span> <span class="token comment">// 父亲fiber</span>
      <span class="token literal-property property">effectTag</span><span class="token operator">:</span> <span class="token constant">INSERT</span><span class="token punctuation">,</span> <span class="token comment">// 副作用标识，包括新增、删除、更新</span>
      <span class="token literal-property property">nextEffect</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 指向下一个fiber，effect list通过nextEffect指针进行连接</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newChildIndex <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currentFiber<span class="token punctuation">.</span>child <span class="token operator">=</span> newFiber <span class="token comment">// child为大儿子</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        prevSibling<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber <span class="token comment">// 让大儿子的sibling指向二儿子</span>
      <span class="token punctuation">}</span>
      prevSibling <span class="token operator">=</span> newFiber
    <span class="token punctuation">}</span>
    newChildIndex<span class="token operator">++</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义一个方法收集此 fiber 节点下所有的副作用，并组成<code>effect list</code>。注意每个 fiber 有两个属性：</p><ul><li>firstEffect：指向第一个有副作用的子fiber</li><li>lastEffect：指向最后一个有副作用的子fiber</li></ul><p>中间的使用<code>nextEffect</code>做成一个单链表。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 在完成的时候要收集有副作用的fiber，组成effect list</span>
<span class="token keyword">const</span> <span class="token function-variable function">completeUnitOfWork</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">currentFiber</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 后续遍历，儿子们完成之后，自己才能完成。最后会得到以上图中的链条结构。</span>
  <span class="token keyword">let</span> returnFiber <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>return
  <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果父亲fiber的firstEffect没有值，则将其指向当前fiber的firstEffect</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>returnFiber<span class="token punctuation">.</span>firstEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      returnFiber<span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>firstEffect
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果当前fiber的lastEffect有值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>firstEffect
      <span class="token punctuation">}</span>
      returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>lastEffect
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>effectTag
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 说明有副作用</span>
      <span class="token comment">// 每个fiber有两个属性：</span>
      <span class="token comment">// 1）firstEffect：指向第一个有副作用的子fiber</span>
      <span class="token comment">// 2）lastEffect：指向最后一个有副作用的子fiber</span>
      <span class="token comment">// 中间的使用nextEffect做成一个单链表</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> currentFiber
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> currentFiber
      <span class="token punctuation">}</span>
      returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> currentFiber
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来定义一个递归函数，从根节点出发，把全部的 fiber 节点遍历一遍，产出最终全部的<code>effect list</code>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 把该节点和子节点任务都执行完</span>
<span class="token keyword">const</span> <span class="token function-variable function">performUnitOfWork</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">currentFiber</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">beginWork</span><span class="token punctuation">(</span>currentFiber<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> currentFiber<span class="token punctuation">.</span>child
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>currentFiber<span class="token punctuation">)</span> <span class="token comment">// 让自己完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 有弟弟则返回弟弟</span>
      <span class="token keyword">return</span> currentFiber<span class="token punctuation">.</span>sibling
    <span class="token punctuation">}</span>
    currentFiber <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>return <span class="token comment">// 没有弟弟，则找到父亲，让父亲完成，父亲会去找他的弟弟即叔叔</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="commit阶段" tabindex="-1"><a class="header-anchor" href="#commit阶段" aria-hidden="true">#</a> commit阶段</h4><p>commit 阶段需要将上阶段计算出来的需要处理的副作用一次性执行，此阶段不能暂停，否则会出现UI更新不连续的现象。此阶段需要根据<code>effect list</code>，将所有更新都 commit 到DOM树上。</p><h5 id="根据一个-fiber-的-effect-list-更新视图" tabindex="-1"><a class="header-anchor" href="#根据一个-fiber-的-effect-list-更新视图" aria-hidden="true">#</a> 根据一个 fiber 的 effect list 更新视图</h5><p>根据一个 fiber 的<code>effect list</code>列表去更新视图（这里只列举了新增节点、删除节点、更新节点的三种操作）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">commitWork</span> <span class="token operator">=</span> <span class="token parameter">currentFiber</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentFiber<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token keyword">let</span> returnFiber <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>return
  <span class="token keyword">let</span> returnDOM <span class="token operator">=</span> returnFiber<span class="token punctuation">.</span>stateNode <span class="token comment">// 父节点元素</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>effectTag <span class="token operator">===</span> <span class="token constant">INSERT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果当前fiber的effectTag标识位INSERT，则代表其是需要插入的节点</span>
    returnDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>effectTag <span class="token operator">===</span> <span class="token constant">DELETE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果当前fiber的effectTag标识位DELETE，则代表其是需要删除的节点</span>
    returnDOM<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>effectTag <span class="token operator">===</span> <span class="token constant">UPDATE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果当前fiber的effectTag标识位UPDATE，则代表其是需要更新的节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">ELEMENT_TEXT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>alternate<span class="token punctuation">.</span>props<span class="token punctuation">.</span>text <span class="token operator">!==</span> currentFiber<span class="token punctuation">.</span>props<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currentFiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">.</span>textContent <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>props<span class="token punctuation">.</span>text
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  currentFiber<span class="token punctuation">.</span>effectTag <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="根据全部fiber的effect-list-更新视图" tabindex="-1"><a class="header-anchor" href="#根据全部fiber的effect-list-更新视图" aria-hidden="true">#</a> 根据全部fiber的effect list 更新视图</h5><p>写一个递归函数，从根节点出发，根据<code>effect list</code>完成全部更新：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">commitRoot</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currentFiber <span class="token operator">=</span> workInProgressRoot<span class="token punctuation">.</span>firstEffect
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commitWork</span><span class="token punctuation">(</span>currentFiber<span class="token punctuation">)</span>
    currentFiber <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>nextEffect
  <span class="token punctuation">}</span>
  currentRoot <span class="token operator">=</span> workInProgressRoot <span class="token comment">// 把当前渲染成功的根fiber赋给currentRoot</span>
  workInProgressRoot <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="完成视图更新" tabindex="-1"><a class="header-anchor" href="#完成视图更新" aria-hidden="true">#</a> 完成视图更新</h5><p>接下来定义循环执行工作，当计算完成每个 fiber 的<code>effect list</code>后，调用 commitRoot 完成视图更新：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">workloop</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> shouldYield <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 是否需要让出控制权</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>shouldYield<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nextUnitOfWork <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>nextUnitOfWork<span class="token punctuation">)</span>
    shouldYield <span class="token operator">=</span> deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token comment">// 如果执行完任务后，剩余时间小于1ms，则需要让出控制权给浏览器</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nextUnitOfWork <span class="token operator">&amp;&amp;</span> workInProgressRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;render阶段结束&#39;</span><span class="token punctuation">)</span>
    <span class="token function">commitRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 没有下一个任务了，根据effect list结果批量更新视图</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 请求浏览器进行再次调度</span>
  <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>workloop<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">1000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这时，已经根据收集到的变更信息，完成了视图的刷新操作。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1812809429@qq.com">FLY200117</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/fyblog/pages/Web/frame/React.html" class="" aria-label="基础目录"><!--[--><!--]--> 基础目录 <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--[--><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!--]--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/fyblog/assets/app.1281bbb5.js" defer></script>
  </body>
</html>
